package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"text/template"
)

type TroopStats struct {
	Operation string  `json:"operation"`
	HP        int     `json:"hp"`
	Damage    int     `json:"damage"`
	Level     int     `json:"level"`
	Speed     float64 `json:"Speed"`
	Range     int     `json:"Range"`
}

const knightTemplate = `package troops

import (
	"cse-110-project-team-30/backend/internal/battle/common"
	"cse-110-project-team-30/backend/internal/util"
)

type {{.Type}} struct {
	Troop
}

func New{{.Type}}(team common.Team, pos common.Position) Entity {
	return &{{.Type}}{
		Troop: Troop{
			Type:     "{{.Type}}",
			Health:   {{.HP}},
			Damage:   {{.Damage}},
			Speed:    {{.Speed}},
			Range:    {{.Range}},
			Position: pos,
			Team:     team,
		},
	}
}

func (t *{{.Type}}) CalculateAction(mv MapView) Action {
	action := Action{
		NextPosition: t.Position,
		AttackTarget: nil,
		Damage:       0,
	}

	enemy, path := mv.FindNearestEnemyBFS(t)
	if enemy == nil || len(path) == 0 {
		return action
	}

	if len(path) == 1 || util.GetDistance(t.Position, enemy.GetPosition()) <= float64(t.Range) {
		action.AttackTarget = enemy
		action.Damage = t.Damage
		return action
	}

	if len(path) > 1 {
		action.NextPosition = path[1]
	}
	return action
}
`

const registryTemplate = `package troops

import "cse-110-project-team-30/backend/internal/battle/common"

// TroopRegistry maps string keys to constructor functions.
var TroopRegistry = map[string]func(team common.Team, pos common.Position) Entity{
{{- range . }}
	"{{.}}": New{{.}},
{{- end }}
}

// NewTroopByType creates a new troop by its type string.
func NewTroopByType(troopType string, team common.Team, pos common.Position) Entity {
	if constructor, ok := TroopRegistry[troopType]; ok {
		return constructor(team, pos)
	}
	return nil
}

// AvailableTroopTypes returns all keys in the registry
func AvailableTroopTypes() []string {
	keys := make([]string, 0, len(TroopRegistry))
	for k := range TroopRegistry {
		keys = append(keys, k)
	}
	return keys
}
`

func main() {
	// Flags
	outDir := flag.String("o", "./troops", "output directory for generated files")
	flag.Parse()

	if flag.NArg() < 1 {
		log.Fatal("Usage: go run generate_troops.go [-o output_dir] <path-to-json>")
	}
	jsonPath := flag.Arg(0)

	// Load JSON
	jsonBytes, err := ioutil.ReadFile(jsonPath)
	if err != nil {
		log.Fatal(err)
	}

	var statsMap map[string]TroopStats
	if err := json.Unmarshal(jsonBytes, &statsMap); err != nil {
		log.Fatal(err)
	}

	// Create output directory
	if err := os.MkdirAll(*outDir, 0755); err != nil {
		log.Fatal(err)
	}

	// Prepare templates
	tmpl, err := template.New("troop").Parse(knightTemplate)
	if err != nil {
		log.Fatal(err)
	}

	regTmpl, err := template.New("registry").Parse(registryTemplate)
	if err != nil {
		log.Fatal(err)
	}

	// Keep track of keys for registry
	keys := []string{}

	// Generate troop files
	for key, stats := range statsMap {
		if stats.Speed == 0 {
			stats.Speed = 1.0
		}
		if stats.Range == 0 {
			stats.Range = 1
		}

		filename := fmt.Sprintf("%s/autogenerated_%s.go", *outDir, key)
		f, err := os.Create(filename)
		if err != nil {
			log.Fatal(err)
		}

		data := struct {
			Type   string
			HP     int
			Damage int
			Speed  float64
			Range  int
		}{
			Type:   key,
			HP:     stats.HP,
			Damage: stats.Damage,
			Speed:  stats.Speed,
			Range:  stats.Range,
		}

		if err := tmpl.Execute(f, data); err != nil {
			log.Fatal(err)
		}
		f.Close()
		fmt.Println("Generated:", filename)

		keys = append(keys, key)
	}

	// Generate TroopRegistry.go
	regFile := fmt.Sprintf("%s/TroopRegistry.go", *outDir)
	f, err := os.Create(regFile)
	if err != nil {
		log.Fatal(err)
	}
	if err := regTmpl.Execute(f, keys); err != nil {
		log.Fatal(err)
	}
	f.Close()
	fmt.Println("Generated:", regFile)
}
